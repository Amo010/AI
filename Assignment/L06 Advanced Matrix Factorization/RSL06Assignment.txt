一、课上理解部分					
原理1 常用的推荐算法都有哪些（SVD算法在推荐系统算法中的位置）
常用的推荐算法分为：
(1)基于内容的推荐
(2)基于协同过滤：
   基于领域/内存的推荐：
       UserCF、ItemCF
   基于模型的推荐：
       隐语义模型(LFM)：
           LDA
           矩阵分解(MF):EVD(特征值分解)、SVD(奇异值分解)
       贝叶斯网络
       SVM
	
原理2 普通矩阵分解原理
普通矩阵根据特征分解，特征分解是将矩阵分解为特征值和特征向量表示的矩阵之积的方法，也称为谱分解。
N维非零向量v是N*N的矩阵A的特征向量，当且仅当Av=入v,入为特征值(标量)，v为对应入对应的特征向量。
特征向量被施以线性变换A只会使向量伸长或缩短，而方向保持不变。
				
原理3 对称矩阵分解原理
如果A是对称矩阵，那么U^T=U^-1   A=U∩U^T
U的列向量是A的特征向量，∩是对角矩阵，元素是特征向量的特征值
				
原理4 奇异值分解SVD原理
假设A是一个N * M的矩阵，那么得到的U是一个N * N的方阵（里面的向量是正交的，U里面的向量称为左奇异向量），
Σ是一个N * M的矩阵（除了对角线的元素都是0，对角线上的元素称为奇异值），V’(V的转置)是一个N * N的矩阵，
里面的向量也是正交的，V里面的向量称为右奇异向量）
				
原理5 基于流行度的推荐算法
基于内容的流行程度，也称之为热度，将榜单中的热度推荐给用户
基于流行读计算产生的推荐模型
解决冷启动问题：根据流行度来推荐商品的算法，即什么内容吸引用户，就给用户推荐什么内容
				
原理6 影响流行度的因素
影响因素有时间因素、空间因素、社会心理因素、个性VS群体
				
原理7 推荐系统的架构
在线部分;分为召回阶段和排序阶段
近先部分：实时收集用户行为反馈，并选择训练实例，抽取特征=>更新在线推荐模型
离线部分：整理离线训练数据=>周期性更新推荐模型
					
原理8 传统SVD在推荐系统中的应用功能
可以通过k来对矩阵进行降维Mm*n=Um*kΣk*kV^Tk*n
第i个用户对第j个物品的评分U^TiΣk*kVj
完整的SVD，可以将M无损的分解成为三个矩阵
为了简化矩阵分解，可使用k，远小于min(m,n),对矩阵M近似还原
				
原理9 funkSVD算法原理
最小化损失函数
为了防止过拟合增加正则项
step1，通过梯度下降法，求解P和Q使得损失函数最小化
step2，通过P和Q将矩阵补全
step3，针对某个用户i，查找之前值缺失的位置，按照补全值从大到小进行推荐
				
原理10 BiasSVD算法原理
用户有自己的偏好(Bias)，商品也有自己的偏好(Bias),将与个性无关的部分设置为偏好(Bias)部分，
优化目标函数，在迭代过程中，bi,bj的初始值可以设置为0向量，然后进行迭代，最终得到P和Q。
				
原理11 SVD++算法原理
在BiasSVD算法基础上进行了改进，考虑用户的隐式反馈,隐式反馈是指没有具体的评分，但可能有点击、浏览等行为。
对于某一个用户i，假设他的隐式反馈item集合为I(i)，用户i对商品j对应的隐式反馈正值为Cij，用户i所有的隐式反馈修正值之和为ΣCsj.
优化目标函数，在考虑用户隐式反馈的情况下，最终得到P和Q。

工具：如何使用Python进行SVD分解				
工具：使用SVD对图像进行压缩重构				
工具：Surprise中对应的SVD工具	MovieLens			
工具：Google Colab编辑
工具：powerbi可视化面板使用
				
二、课下思考与练习					
Thinking1 奇异值分解SVD的原理是怎样的，都有哪些应用场景 
"1、能简单说明奇异值分解的原理 2、举例说明两个以上的使用场景 "	
奇异值分解SVD原理：假设A是一个N * M的矩阵，那么得到的U是一个N * N的方阵（里面的向量是正交的，U里面的向量称为左奇异向量），
Σ是一个N * M的矩阵（除了对角线的元素都是0，对角线上的元素称为奇异值），V’(V的转置)是一个N * N的矩阵，
里面的向量也是正交的，V里面的向量称为右奇异向量）
应用场景：图片压缩、通过k来对矩阵进行降维

Thinking2 FunkSVD, BiasSVD，SVD++算法之间的区别是怎样的	 "1、能简述3种算法之间的差异 "	
FunkSVD算法：通过梯度下降法，求解User矩阵和item矩阵使得损失函数最小化
BiasSVD算法：在FunkSVD算法基础上考虑用户和商品偏好部分
SVD++算法：在BiasSVD算法基础上考虑隐式反馈

Thinking3 矩阵分解算法在推荐系统中有哪些应用场景，存在哪些不足 
"1、能说明推荐系统中的典型应用场景 2、MF在推荐系统中的局限性 "	
应用场景：
可以通过k来对矩阵进行降维Mm*n=Um*kΣk*kV^Tk*n
第i个用户对第j个物品的评分U^TiΣk*kVj
完整的SVD，可以将M无损的分解成为三个矩阵
为了简化矩阵分解，可使用k，远小于min(m,n),对矩阵M近似还原

局限性：
SVD矩阵分解要求矩阵是稠密的=>矩阵中的元素不能有缺失，所有类似于数据清洗，需要先对矩阵中的缺失元素进行补全
而矩阵往往是稀疏的，大量缺失，导致计算量大；填充的方式简单粗暴，导致噪声大。

Thinking4 item流行度在推荐系统中有怎样的应用 
"1、冷启动中的使用 2、协同过滤中的TopN推荐 3、其他使用 "	
冷启动中，当用户行为信息不足时，采用非个性化推荐，算法的本质是什么内容吸引用户就给用户推荐什么内容。
但也需要有代表性和区分性，即不能太大众化或者老少皆宜，这样导致无法区分用户的兴趣。为了增加多样性，
用户兴趣的可能性很多，为了匹配兴趣的多样性，提供具有较高覆盖率的启动item集合，这些物品能覆盖主流的用户兴趣。
协同过滤中的TopN推荐是指将榜单中热度的内容推荐给用户，是基于流行度的推荐，围绕流行度计算产生的推荐模型。

Thinking5 推荐系统的召回阶段都有哪些策略 
"1、能说出3种以上的召回策略 2、>3种 "	
推荐系统的召回阶段的策略有协同过滤、FM模型、向量化召回、深度树匹配模型、主题模型、内容召回、热点召回

Action1	选择任意一张图片，对其进行灰度化，然后使用SVD进行图像的重构，当奇异值数量为原有的1%，10%，50%时，输出重构后的图像			
1、完成代码，结果正确
import numpy as np
from scipy.linalg import svd
from PIL import Image
import matplotlib.pyplot as plt
# 取前k个特征，对图像进行还原
def get_image_feature(s, k):
	# 对于S，只保留前K个特征值
	s_temp = np.zeros(s.shape[0])
	s_temp[0:k] = s[0:k]
	s = s_temp * np.identity(s.shape[0])
	# 用新的s_temp，以及p,q重构A
	temp = np.dot(p,s)
	temp = np.dot(temp,q)
	plt.imshow(temp, cmap=plt.cm.gray, interpolation='nearest')
	plt.show()
	print(A-temp)
# 加载256色图片
image = Image.open('./256.bmp')
A = np.array(image)
# 显示原图像
plt.imshow(A, cmap=plt.cm.gray, interpolation='nearest')
plt.show()
# 对图像矩阵A进行奇异值分解，得到p,s,q
p,s,q = svd(A, full_matrices=False)
# 取前k个特征，对图像进行还原
get_image_feature(s, 5)
get_image_feature(s, 50)
get_image_feature(s, 500)



Action2	使用Google Colab编辑器，对MovieLens数据集进行评分预测，计算RMSE（使用funkSVD, BiasSVD，SVD++）			
"1、使用Colab完成3种算法在MovieLens的评分预测 2、使用Surprise以外的工具"	


Action3	使用PowerBI（或其他工具），对nCoV数据进行可视化呈现 "可以使用PowerBI或其他工具对nCoV数据进行探索"

	
